import numpy as np
from ..basic_mutation import basic_mutation

class MDE_pBX(basic_mutation):
    # current to group best
    def get_parameters_numbers(self):
    # F --scaling factor --typiclally 0.4<=F<=1 
        return 2
    # def mutation(self, env,individual_indice):
    #     """
    #     Perform mutation on an individual in the population.
    #     Args:
    #         env (Environment): The environment object containing the population.
    #         individual_indice (int): The index of the individual to mutate.
    #     Returns:
    #         numpy.ndarray: The mutated individual.
    #     Raises:
    #         None
    #     """

    #     population_object=env.population
    #     parameters=env.action['mutation_parameters']
        
    #     population=population_object.current_vector
    #     F = parameters[0]
    #     q=  15*0.01
    #     # "it is seen that keeping the group size equal to 15%
    #     # of the population size provides very good results on majority of
    #     # the tested benchmarks."
    #     # q = parameters[1]
    #     # e.g. 0.05<=q<=0.65 
    #     Len=population_object.pop_size
        
    #     group_size=int(Len*q)
    #     # for i in range(Len):
    #     group_indices=random.sample(range(Len),group_size)
    #     group_best_indice=group_indices[0]
    #     group_best=population_object.current_fitness[group_best_indice]
    #     for j in group_indices:
    #         if population_object.current_fitness[j]<group_best:
    #             group_best_indice=j
    #             group_best=population_object.current_fitness[j]
        
    #     indices=random.sample(range(Len),2)
    #     x1,x2=population[indices[0]],population[indices[1]]
    #     # print("hello")
    #     # none of them is equal to Xgr_best,G or the target
    #     # vector to ensure that none of the vectors is equal in (6). Unde
    #     while ( np.array_equal(x1, group_best) or 
    #             np.array_equal(x2, group_best) or 
    #             np.array_equal(x1, population[individual_indice]) or 
    #             np.array_equal(x2, population[individual_indice])):
    #         # print("get new indices")
    #         indices = random.sample(range(Len), 2)
    #         x1, x2 = population[indices[0]], population[indices[1]]
    #     mutated_vector=population[individual_indice]+F*(population[group_best_indice]-population[individual_indice]+x1-x2)
    #     # print('origin_individual:',population[individual_indice])
    #     # print('new_individual',mutated_vector)
    #     new_individual=mutated_vector
    #     return new_individual
    
    # population version
    def mutation(self,env,indexs,parameters):
        """
        Perform mutation operation on the population.
        This method generates a mutated vector based on the current population,
        group best vector, and random vectors selected from the population.
        Args:
            env (Environment): The environment object containing the population and mutation parameters.
            indexs (list): List of indices used to construct the group best vector.
        Returns:
            numpy.ndarray: The mutated vector generated by the mutation operation.
        """
        
        population_object=env.population
        population=population_object.current_vector
        
        group_best=self.construct_qbest(env,parameters)
        sub_pop=self.construct_sub_vector(env,indexs)
        F=parameters[:,0]
        F = F[:, np.newaxis]
        
        random_indices=self.construct_random_indices(env,len(indexs),2)
        x1,x2=population[random_indices.T]   
        
        mutated_vector=sub_pop+F*(group_best-sub_pop+x1-x2)
        mutated_vector=self.re_boudary(env,mutated_vector)
        return mutated_vector
        
        
    # def construct_group_best(self,env,individual_indice,parameters):
    #     """
    #     Constructs the group best vector.
    #     Args:
    #         env (object): The environment object containing the population.
    #         individual_indice (int): The index of the individual to mutate.
    #     Returns:
    #         numpy.ndarray: The group best vector.
    #     """
        
    #     population_object=env.population
    #     population=population_object.current_vector
    #     Len=population_object.pop_size
    #     q=  parameters[:,1]
        
    #     # todo:modified by network
    #     group_size=q*Len
    #     # 循环做？先每个选出来groupindice？
    #     # 缓慢了
        
        
        
    #     group_indices=np.random.choice(Len,group_size,replace=False)
    #     group_fitness=population_object.current_fitness[group_indices]
    #     group_best_indice=group_indices[np.argmin(group_fitness)]
        
    #     return population[group_best_indice]
        