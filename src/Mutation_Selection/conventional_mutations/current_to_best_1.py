from ..basic_mutation import basic_mutation
import numpy as np

class current_to_best_1(basic_mutation):
    def get_parameters_numbers(self):
        # F --scaling factor 0<=F<=1
        return 1
    

    # population version
    def mutation(self,env,pop_indexs,parameters):
        """
        Perform mutation operation on the population.
        This method applies a differential evolution mutation strategy to generate a mutated vector
        based on the current individual and two randomly selected individuals from the population.
        Args:
            env (object): The environment object containing the population and mutation parameters.
            pop_indexs (list): Indices of the population members to be considered for mutation.
        Returns:
            numpy.ndarray: The mutated vector generated by the mutation operation.
        """
        
        population_object=env.population
        
        F = parameters[:,0]
        F = F[:, np.newaxis]
        population = population_object.current_vector
        best_individual_indice=np.argmin(population_object.current_fitness)
        best_individual=population[best_individual_indice]
        sub_pop=self.construct_sub_vector(env,pop_indexs)
        random_indices=self.construct_random_indices(env,len(pop_indexs),2)
        x1,x2=population[random_indices.T]     
        
        mutated_vector= sub_pop+F*(best_individual-sub_pop)+F*(x1-x2) # is it correct?
        mutated_vector=self.re_boudary(env,mutated_vector)
        
        
        return mutated_vector